;function;descriptions_backup
0;arrange;"arrange() orders the rows of a data frame by the values of selected columns. Unlike other dplyr verbs, arrange() largely ignores grouping; you need to explicitly mention grouping variables (or use  .by_group = TRUE) in order to group by them, and functions of variables are evaluated once per data frame, not once per group."
1;count;count() lets you quickly count the unique values of one or more variables: df %>% count(a, b) is roughly equivalent to df %>% group_by(a, b) %>% summarise(n = n()). count() is paired with tally(), a lower-level helper that is equivalent to df %>% summarise(n = n()). Supply wt to perform weighted counts, switching the summary from n = n() to n = sum(wt). add_count() and add_tally() are equivalents to count() and tally() but use mutate() instead of summarise() so that they add a new column with group-wise counts.
2;tally;count() lets you quickly count the unique values of one or more variables: df %>% count(a, b) is roughly equivalent to df %>% group_by(a, b) %>% summarise(n = n()). count() is paired with tally(), a lower-level helper that is equivalent to df %>% summarise(n = n()). Supply wt to perform weighted counts, switching the summary from n = n() to n = sum(wt). add_count() and add_tally() are equivalents to count() and tally() but use mutate() instead of summarise() so that they add a new column with group-wise counts.
3;add_count;count() lets you quickly count the unique values of one or more variables: df %>% count(a, b) is roughly equivalent to df %>% group_by(a, b) %>% summarise(n = n()). count() is paired with tally(), a lower-level helper that is equivalent to df %>% summarise(n = n()). Supply wt to perform weighted counts, switching the summary from n = n() to n = sum(wt). add_count() and add_tally() are equivalents to count() and tally() but use mutate() instead of summarise() so that they add a new column with group-wise counts.
4;add_tally;count() lets you quickly count the unique values of one or more variables: df %>% count(a, b) is roughly equivalent to df %>% group_by(a, b) %>% summarise(n = n()). count() is paired with tally(), a lower-level helper that is equivalent to df %>% summarise(n = n()). Supply wt to perform weighted counts, switching the summary from n = n() to n = sum(wt). add_count() and add_tally() are equivalents to count() and tally() but use mutate() instead of summarise() so that they add a new column with group-wise counts.
5;distinct;Select only unique/distinct rows from a data frame. This is similar to unique.data.frame() but considerably faster.
6;filter;The filter() function is used to subset a data frame, retaining all rows that satisfy your conditions. To be retained, the row must produce a value of TRUE for all conditions. Note that when a condition evaluates to NA the row will be dropped, unlike base subsetting with [.
7;glimp;glimpse() is like a transposed version of print(): columns run down the page, and data runs across. This makes it possible to see every column in a data frame. It's a little like str() applied to a data frame but it tries to show you as much data as possible. (And it always shows the underlying data, even when applied to a remote data source.) glimpse() is provided by the pillar package, and re-exported by dplyr. See pillar::glimpse() for more details.
8;mutate;"mutate() adds new variables and preserves existing ones; transmute() adds new variables and drops existing ones. New variables overwrite existing variables of the same name. Variables can be removed by setting their value to NULL."
9;transmute;"mutate() adds new variables and preserves existing ones; transmute() adds new variables and drops existing ones. New variables overwrite existing variables of the same name. Variables can be removed by setting their value to NULL."
10;pull;pull() is similar to $. It's mostly useful because it looks a little nicer in pipes, it also works with remote data frames, and it can optionally name the output.
11;relocate;Use relocate() to change column positions, using the same syntax as select() to make it easy to move blocks of columns at once.
12;rename;"rename() changes the names of individual variables using new_name = old_name syntax; rename_with() renames columns using a function."
13;rename_with;"rename() changes the names of individual variables using new_name = old_name syntax; rename_with() renames columns using a function."
14;select;Select (and optionally rename) variables in a data frame, using a concise mini-language that makes it easy to refer to variables based on their name (e.g. a:f selects all columns from a on the left to f on the right). You can also use predicate functions like is.numeric to select variables based on their properties. Overview of selection features Tidyverse selections implement a dialect of R where operators make it easy to select variables:: for selecting a range of consecutive variables. ! for taking the complement of a set of variables. & and | for selecting the intersection or the union of two sets of variables. c() for combining selections. In addition, you can use selection helpers. Some helpers select specific columns:everything(): Matches all variables. last_col(): Select last variable, possibly with an offset. These helpers select variables by matching patterns in their names:starts_with(): Starts with a prefix. ends_with(): Ends with a suffix. contains(): Contains a literal string. matches(): Matches a regular expression. num_range(): Matches a numerical range like x01, x02, x03. These helpers select variables from a character vector:all_of(): Matches variable names in a character vector. All names must be present, otherwise an out-of-bounds error is thrown. any_of(): Same as all_of(), except that no error is thrown for names that don't exist. This helper selects variables with a function:where(): Applies a function to all variables and selects those for which the function returns TRUE.
15;summarise;"summarise() creates a new data frame. It will have one (or more) rows for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarising all observations in the input. It will contain one column for each grouping variable and one column for each of the summary statistics that you have specified. summarise() and summarize() are synonyms."
16;summarize;"summarise() creates a new data frame. It will have one (or more) rows for each combination of grouping variables; if there are no grouping variables, the output will have a single row summarising all observations in the input. It will contain one column for each grouping variable and one column for each of the summary statistics that you have specified. summarise() and summarize() are synonyms."
17;slice;slice() lets you index rows by their (integer) locations. It allows you to select, remove, and duplicate rows. It is accompanied by a number of helpers for common use cases:slice_head() and slice_tail() select the first or last rows. slice_sample() randomly selects rows. slice_min() and slice_max() select rows with highest or lowest values of a variable. If .data is a grouped_df, the operation will be performed on each group, so that (e.g.) slice_head(df, n = 5) will select the first five rows in each group.
18;slice_head;slice() lets you index rows by their (integer) locations. It allows you to select, remove, and duplicate rows. It is accompanied by a number of helpers for common use cases:slice_head() and slice_tail() select the first or last rows. slice_sample() randomly selects rows. slice_min() and slice_max() select rows with highest or lowest values of a variable. If .data is a grouped_df, the operation will be performed on each group, so that (e.g.) slice_head(df, n = 5) will select the first five rows in each group.
19;slice_tail;slice() lets you index rows by their (integer) locations. It allows you to select, remove, and duplicate rows. It is accompanied by a number of helpers for common use cases:slice_head() and slice_tail() select the first or last rows. slice_sample() randomly selects rows. slice_min() and slice_max() select rows with highest or lowest values of a variable. If .data is a grouped_df, the operation will be performed on each group, so that (e.g.) slice_head(df, n = 5) will select the first five rows in each group.
20;slice_min;slice() lets you index rows by their (integer) locations. It allows you to select, remove, and duplicate rows. It is accompanied by a number of helpers for common use cases:slice_head() and slice_tail() select the first or last rows. slice_sample() randomly selects rows. slice_min() and slice_max() select rows with highest or lowest values of a variable. If .data is a grouped_df, the operation will be performed on each group, so that (e.g.) slice_head(df, n = 5) will select the first five rows in each group.
21;slice_max;slice() lets you index rows by their (integer) locations. It allows you to select, remove, and duplicate rows. It is accompanied by a number of helpers for common use cases:slice_head() and slice_tail() select the first or last rows. slice_sample() randomly selects rows. slice_min() and slice_max() select rows with highest or lowest values of a variable. If .data is a grouped_df, the operation will be performed on each group, so that (e.g.) slice_head(df, n = 5) will select the first five rows in each group.
22;slice_sample;slice() lets you index rows by their (integer) locations. It allows you to select, remove, and duplicate rows. It is accompanied by a number of helpers for common use cases:slice_head() and slice_tail() select the first or last rows. slice_sample() randomly selects rows. slice_min() and slice_max() select rows with highest or lowest values of a variable. If .data is a grouped_df, the operation will be performed on each group, so that (e.g.) slice_head(df, n = 5) will select the first five rows in each group.
23;bind_rows;This is an efficient implementation of the common pattern of do.call(rbind, dfs) or do.call(cbind, dfs) for binding many data frames into one.
24;bind_cols;This is an efficient implementation of the common pattern of do.call(rbind, dfs) or do.call(cbind, dfs) for binding many data frames into one.
25;reexpor;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
26;data_fra;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
27;data_fram;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
28;as_data_fra;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
29;l;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
30;ls;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
31;add_r;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
32;type_s;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
33;frame_da;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
34;tribb;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
35;tibb;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
36;as_tibb;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
37;vi;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
38;tbl_s;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
39;contai;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
40;select_helpe;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
41;ends_wi;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
42;everythi;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
43;match;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
44;num_ran;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
45;one_;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
46;starts_wi;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
47;last_c;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
48;any_;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
49;all_;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
50;interse;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
51;uni;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
52;setdi;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
53;setequ;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
54;%;These objects are imported from other packages. Follow the links below to see their documentation. generics intersect, setdiff, setequal, union magrittr %>% tibble add_row, as_data_frame, as_tibble, data_frame, data_frame_, frame_data, lst, lst_, tbl_sum, tibble, tribble, type_sum, view tidyselect all_of, any_of, contains, ends_with, everything, last_col, matches, num_range, one_of, starts_with
55;union_all;These functions override the set functions provided in base to make them generic so that efficient versions for data frames and other tables can be provided. The default methods call the base versions. Beware that intersect(), union() and setdiff() remove duplicates.
56;inner_join;The mutating joins add columns from y to x, matching rows based on the keys:inner_join(): includes all rows in x and y. left_join(): includes all rows in x. right_join(): includes all rows in y. full_join(): includes all rows in x or y. If a row in x matches multiple rows in y, all the rows in y will be returned once for each matching row in x.
57;left_join;The mutating joins add columns from y to x, matching rows based on the keys:inner_join(): includes all rows in x and y. left_join(): includes all rows in x. right_join(): includes all rows in y. full_join(): includes all rows in x or y. If a row in x matches multiple rows in y, all the rows in y will be returned once for each matching row in x.
58;right_join;The mutating joins add columns from y to x, matching rows based on the keys:inner_join(): includes all rows in x and y. left_join(): includes all rows in x. right_join(): includes all rows in y. full_join(): includes all rows in x or y. If a row in x matches multiple rows in y, all the rows in y will be returned once for each matching row in x.
59;full_join;The mutating joins add columns from y to x, matching rows based on the keys:inner_join(): includes all rows in x and y. left_join(): includes all rows in x. right_join(): includes all rows in y. full_join(): includes all rows in x or y. If a row in x matches multiple rows in y, all the rows in y will be returned once for each matching row in x.
60;nest_join;nest_join() returns all rows and columns in x with a new nested-df column that contains all matches from y. When there is no match, the list column is a 0-row tibble.
61;semi_join;Filtering joins filter rows from x based on the presence or absence of matches in y:semi_join() return all rows from x with a match in y. anti_join() return all rows from x without a match in y.
62;anti_join;Filtering joins filter rows from x based on the presence or absence of matches in y:semi_join() return all rows from x with a match in y. anti_join() return all rows from x without a match in y.
63;group_by;"Most data operations are done on groups defined by variables. group_by() takes an existing tbl and converts it into a grouped tbl where operations are performed ""by group"". ungroup() removes grouping."
64;ungroup;"Most data operations are done on groups defined by variables. group_by() takes an existing tbl and converts it into a grouped tbl where operations are performed ""by group"". ungroup() removes grouping."
65;group_cols;This selection helpers matches grouping variables. It can be used in select() or vars() selections.
66;rowwise;rowwise() allows you to compute on a data frame a row-at-a-time. This is most useful when a vectorised function doesn't exist. Most dplyr verbs preserve row-wise grouping. The exception is summarise(), which return a grouped_df. You can explicitly ungroup with ungroup() or as_tibble(), or convert to a grouped_df with group_by().
67;across;"across() makes it easy to apply the same transformation to multiple columns, allowing you to use select() semantics inside in ""data-masking"" functions like summarise() and mutate(). See vignette(""colwise"") for more details. if_any() and if_all() apply the same predicate function to a selection of columns and combine the results into a single logical vector: if_any() is TRUE when the predicate is TRUE for any of the selected columns, if_all() is TRUE when the predicate is TRUE for all selected columns. across() supersedes the family of ""scoped variants"" like summarise_at(), summarise_if(), and summarise_all()."
68;if_any;"across() makes it easy to apply the same transformation to multiple columns, allowing you to use select() semantics inside in ""data-masking"" functions like summarise() and mutate(). See vignette(""colwise"") for more details. if_any() and if_all() apply the same predicate function to a selection of columns and combine the results into a single logical vector: if_any() is TRUE when the predicate is TRUE for any of the selected columns, if_all() is TRUE when the predicate is TRUE for all selected columns. across() supersedes the family of ""scoped variants"" like summarise_at(), summarise_if(), and summarise_all()."
69;if_all;"across() makes it easy to apply the same transformation to multiple columns, allowing you to use select() semantics inside in ""data-masking"" functions like summarise() and mutate(). See vignette(""colwise"") for more details. if_any() and if_all() apply the same predicate function to a selection of columns and combine the results into a single logical vector: if_any() is TRUE when the predicate is TRUE for any of the selected columns, if_all() is TRUE when the predicate is TRUE for all selected columns. across() supersedes the family of ""scoped variants"" like summarise_at(), summarise_if(), and summarise_all()."
70;c_across;"c_across() is designed to work with rowwise() to make it easy to perform row-wise aggregations. It has two differences from c():It uses tidy select semantics so you can easily select multiple variables. See vignette(""rowwise"") for more details. It uses vctrs::vec_c() in order to give safer outputs."
71;between;This is a shortcut for x >= left & x <= right, implemented efficiently in C++ for local values, and translated to the appropriate SQL for remote tables.
72;case_when;This function allows you to vectorise multiple if_else() statements. It is an R equivalent of the SQL CASE WHEN statement. If no cases match, NA is returned.
73;coalesce;Given a set of vectors, coalesce() finds the first non-missing value at each position. This is inspired by the SQL COALESCE function which does the same thing for NULLs.
74;cumall;dplyr provides cumall(), cumany(), and cummean() to complete R's set of cumulative functions.
75;cumany;dplyr provides cumall(), cumany(), and cummean() to complete R's set of cumulative functions.
76;cummean;dplyr provides cumall(), cumany(), and cummean() to complete R's set of cumulative functions.
77;desc;Transform a vector into a format that will be sorted in descending order. This is useful within arrange().
78;if_else;Compared to the base ifelse(), this function is more strict. It checks that true and false are the same type. This strictness makes the output type more predictable, and makes it somewhat faster.
79;lag;"Find the ""previous"" (lag()) or ""next"" (lead()) values in a vector. Useful for comparing values behind of or ahead of the current values."
80;lead;"Find the ""previous"" (lag()) or ""next"" (lead()) values in a vector. Useful for comparing values behind of or ahead of the current values."
81;order_by;This function makes it possible to control the ordering of window functions in R that don't have a specific ordering parameter. When translated to SQL it will modify the order clause of the OVER function.
82;n;"These functions return information about the ""current"" group or ""current"" variable, so only work inside specific contexts like summarise() and mutate()n() gives the current group size. cur_data() gives the current data for the current group (excluding grouping variables). cur_data_all() gives the current data for the current group (including grouping variables) cur_group() gives the group keys, a tibble with one row and one column for each grouping variable. cur_group_id() gives a unique numeric identifier for the current group. cur_group_rows() gives the row indices for the current group. cur_column() gives the name of the current column (in across() only). See group_data() for equivalent functions that return values for all groups."
83;cur_data;"These functions return information about the ""current"" group or ""current"" variable, so only work inside specific contexts like summarise() and mutate()n() gives the current group size. cur_data() gives the current data for the current group (excluding grouping variables). cur_data_all() gives the current data for the current group (including grouping variables) cur_group() gives the group keys, a tibble with one row and one column for each grouping variable. cur_group_id() gives a unique numeric identifier for the current group. cur_group_rows() gives the row indices for the current group. cur_column() gives the name of the current column (in across() only). See group_data() for equivalent functions that return values for all groups."
84;cur_data_all;"These functions return information about the ""current"" group or ""current"" variable, so only work inside specific contexts like summarise() and mutate()n() gives the current group size. cur_data() gives the current data for the current group (excluding grouping variables). cur_data_all() gives the current data for the current group (including grouping variables) cur_group() gives the group keys, a tibble with one row and one column for each grouping variable. cur_group_id() gives a unique numeric identifier for the current group. cur_group_rows() gives the row indices for the current group. cur_column() gives the name of the current column (in across() only). See group_data() for equivalent functions that return values for all groups."
85;cur_group;"These functions return information about the ""current"" group or ""current"" variable, so only work inside specific contexts like summarise() and mutate()n() gives the current group size. cur_data() gives the current data for the current group (excluding grouping variables). cur_data_all() gives the current data for the current group (including grouping variables) cur_group() gives the group keys, a tibble with one row and one column for each grouping variable. cur_group_id() gives a unique numeric identifier for the current group. cur_group_rows() gives the row indices for the current group. cur_column() gives the name of the current column (in across() only). See group_data() for equivalent functions that return values for all groups."
86;cur_group_id;"These functions return information about the ""current"" group or ""current"" variable, so only work inside specific contexts like summarise() and mutate()n() gives the current group size. cur_data() gives the current data for the current group (excluding grouping variables). cur_data_all() gives the current data for the current group (including grouping variables) cur_group() gives the group keys, a tibble with one row and one column for each grouping variable. cur_group_id() gives a unique numeric identifier for the current group. cur_group_rows() gives the row indices for the current group. cur_column() gives the name of the current column (in across() only). See group_data() for equivalent functions that return values for all groups."
87;cur_group_rows;"These functions return information about the ""current"" group or ""current"" variable, so only work inside specific contexts like summarise() and mutate()n() gives the current group size. cur_data() gives the current data for the current group (excluding grouping variables). cur_data_all() gives the current data for the current group (including grouping variables) cur_group() gives the group keys, a tibble with one row and one column for each grouping variable. cur_group_id() gives a unique numeric identifier for the current group. cur_group_rows() gives the row indices for the current group. cur_column() gives the name of the current column (in across() only). See group_data() for equivalent functions that return values for all groups."
88;cur_column;"These functions return information about the ""current"" group or ""current"" variable, so only work inside specific contexts like summarise() and mutate()n() gives the current group size. cur_data() gives the current data for the current group (excluding grouping variables). cur_data_all() gives the current data for the current group (including grouping variables) cur_group() gives the group keys, a tibble with one row and one column for each grouping variable. cur_group_id() gives a unique numeric identifier for the current group. cur_group_rows() gives the row indices for the current group. cur_column() gives the name of the current column (in across() only). See group_data() for equivalent functions that return values for all groups."
89;n_distinct;This is a faster and more concise equivalent of length(unique(x))
90;na_if;This is a translation of the SQL command NULLIF. It is useful if you want to convert an annoying value to NA.
91;near;This is a safe way of comparing if two vectors of floating point numbers are (pairwise) equal.  This is safer than using ==, because it has a built in tolerance
92;nth;These are straightforward wrappers around [[. The main advantage is that you can provide an optional secondary vector that defines the ordering, and provide a default value to use when the input is shorter than expected.
93;first;These are straightforward wrappers around [[. The main advantage is that you can provide an optional secondary vector that defines the ordering, and provide a default value to use when the input is shorter than expected.
94;last;These are straightforward wrappers around [[. The main advantage is that you can provide an optional secondary vector that defines the ordering, and provide a default value to use when the input is shorter than expected.
95;row_number;Six variations on ranking functions, mimicking the ranking functions described in SQL2003. They are currently implemented using the built in rank function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use desc() to reverse the direction.
96;ntile;Six variations on ranking functions, mimicking the ranking functions described in SQL2003. They are currently implemented using the built in rank function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use desc() to reverse the direction.
97;min_rank;Six variations on ranking functions, mimicking the ranking functions described in SQL2003. They are currently implemented using the built in rank function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use desc() to reverse the direction.
98;dense_rank;Six variations on ranking functions, mimicking the ranking functions described in SQL2003. They are currently implemented using the built in rank function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use desc() to reverse the direction.
99;percent_rank;Six variations on ranking functions, mimicking the ranking functions described in SQL2003. They are currently implemented using the built in rank function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use desc() to reverse the direction.
100;cume_dist;Six variations on ranking functions, mimicking the ranking functions described in SQL2003. They are currently implemented using the built in rank function, and are provided mainly as a convenience when converting between R and SQL. All ranking functions map smallest inputs to smallest outputs. Use desc() to reverse the direction.
101;recode;"This is a vectorised version of switch(): you can replace numeric values based on their position or their name, and character or factor values only by their name. This is an S3 generic: dplyr provides methods for numeric, character, and factors. For logical vectors, use if_else(). For more complicated criteria, use case_when(). You can use recode() directly with factors; it will preserve the existing order of levels while changing the values. Alternatively, you can use recode_factor(), which will change the order of levels to match the order of replacements. See the forcats package for more tools for working with factors and their levels. recode() is questioning because the arguments are in the wrong order. We have new <- old, mutate(df, new = old), and rename(df, new = old) but recode(x, old = new). We don't yet know how to fix this problem, but it's likely to involve creating a new function then retiring or deprecating recode()."
102;recode_factor;"This is a vectorised version of switch(): you can replace numeric values based on their position or their name, and character or factor values only by their name. This is an S3 generic: dplyr provides methods for numeric, character, and factors. For logical vectors, use if_else(). For more complicated criteria, use case_when(). You can use recode() directly with factors; it will preserve the existing order of levels while changing the values. Alternatively, you can use recode_factor(), which will change the order of levels to match the order of replacements. See the forcats package for more tools for working with factors and their levels. recode() is questioning because the arguments are in the wrong order. We have new <- old, mutate(df, new = old), and rename(df, new = old) but recode(x, old = new). We don't yet know how to fix this problem, but it's likely to involve creating a new function then retiring or deprecating recode()."
103;band_membe;These data sets describe band members of the Beatles and Rolling Stones. They are toy data sets that can be displayed in their entirety on a slide (e.g. to demonstrate a join).
104;band_instrumen;These data sets describe band members of the Beatles and Rolling Stones. They are toy data sets that can be displayed in their entirety on a slide (e.g. to demonstrate a join).
105;band_instrument;These data sets describe band members of the Beatles and Rolling Stones. They are toy data sets that can be displayed in their entirety on a slide (e.g. to demonstrate a join).
106;starwa;The original data, from SWAPI, the Star Wars API, https://swapi.dev/, has been revised to reflect additional research into gender and sex determinations of characters.
107;stor;This data is a subset of the NOAA Atlantic hurricane database best track data, https://www.nhc.noaa.gov/data/#hurdat. The data includes the positions and attributes of storms from 1975-2020, measured every six hours during the lifetime of a storm.
108;auto_copy;Copy tables to same source, if necessary
109;compute;compute() stores results in a remote temporary table. collect() retrieves data into a local tibble. collapse() is slightly different: it doesn't force computation, but instead forces generation of the SQL query. This is sometimes needed to work around bugs in dplyr's SQL generation. All functions preserve grouping and ordering.
110;collect;compute() stores results in a remote temporary table. collect() retrieves data into a local tibble. collapse() is slightly different: it doesn't force computation, but instead forces generation of the SQL query. This is sometimes needed to work around bugs in dplyr's SQL generation. All functions preserve grouping and ordering.
111;collapse;compute() stores results in a remote temporary table. collect() retrieves data into a local tibble. collapse() is slightly different: it doesn't force computation, but instead forces generation of the SQL query. This is sometimes needed to work around bugs in dplyr's SQL generation. All functions preserve grouping and ordering.
112;copy_to;This function uploads a local data frame into a remote data source, creating the table definition as needed. Wherever possible, the new object will be temporary, limited to the current connection to the source.
113;ident;ident() takes unquoted strings and flags them as identifiers. ident_q() assumes its input has already been quoted, and ensures it does not get quoted again. This is currently used only for schema.table.
114;explain;This is a generic function which gives more details about an object than print(), and is more focused on human readable output than str().
115;show_query;This is a generic function which gives more details about an object than print(), and is more focused on human readable output than str().
116;tbl;This is a generic method that dispatches based on the first argument.
117;is.tbl;This is a generic method that dispatches based on the first argument.
118;sql;These functions are critical when writing functions that translate R functions to sql functions. Typically a conversion function should escape all its inputs and return an sql object.
119;group_map;group_map(), group_modify() and group_walk() are purrr-style functions that can be used to iterate on grouped tibbles.
120;group_modify;group_map(), group_modify() and group_walk() are purrr-style functions that can be used to iterate on grouped tibbles.
121;group_walk;group_map(), group_modify() and group_walk() are purrr-style functions that can be used to iterate on grouped tibbles.
122;group_trim;Drop unused levels of all factors that are used as grouping variables, then recalculates the grouping structure. group_trim() is particularly useful after a filter() that is intended to select a subset of groups.
123;group_split;group_split() works like base::split() butit uses the grouping structure from group_by() and therefore is subject to the data mask it does not name the elements of the list based on the grouping as this typically loses information and is confusing. group_keys() explains the grouping structure, by returning a data frame that has one row per group and one column per grouping variable.
124;with_groups;This is an experimental new function that allows you to modify the grouping variables for a single operation.
125;rows_insert;These functions provide a framework for modifying rows in a table using a second table of data. The two tables are matched by a set of key variables whose values typically uniquely identify each row. The functions are inspired by SQL's INSERT, UPDATE, and DELETE, and can optionally modify in_place for selected backends.rows_insert() adds new rows (like INSERT). By default, key values in y must not exist in x. rows_append() works like rows_insert() but ignores keys. rows_update() modifies existing rows (like UPDATE). Key values in y must be unique, and, by default, key values in y must exist in x. rows_patch() works like rows_update() but only overwrites NA values. rows_upsert() inserts or updates depending on whether or not the key value in y already exists in x. Key values in y must be unique. rows_delete() deletes rows (like DELETE). By default, key values in y must exist in x.
126;rows_append;These functions provide a framework for modifying rows in a table using a second table of data. The two tables are matched by a set of key variables whose values typically uniquely identify each row. The functions are inspired by SQL's INSERT, UPDATE, and DELETE, and can optionally modify in_place for selected backends.rows_insert() adds new rows (like INSERT). By default, key values in y must not exist in x. rows_append() works like rows_insert() but ignores keys. rows_update() modifies existing rows (like UPDATE). Key values in y must be unique, and, by default, key values in y must exist in x. rows_patch() works like rows_update() but only overwrites NA values. rows_upsert() inserts or updates depending on whether or not the key value in y already exists in x. Key values in y must be unique. rows_delete() deletes rows (like DELETE). By default, key values in y must exist in x.
127;rows_update;These functions provide a framework for modifying rows in a table using a second table of data. The two tables are matched by a set of key variables whose values typically uniquely identify each row. The functions are inspired by SQL's INSERT, UPDATE, and DELETE, and can optionally modify in_place for selected backends.rows_insert() adds new rows (like INSERT). By default, key values in y must not exist in x. rows_append() works like rows_insert() but ignores keys. rows_update() modifies existing rows (like UPDATE). Key values in y must be unique, and, by default, key values in y must exist in x. rows_patch() works like rows_update() but only overwrites NA values. rows_upsert() inserts or updates depending on whether or not the key value in y already exists in x. Key values in y must be unique. rows_delete() deletes rows (like DELETE). By default, key values in y must exist in x.
128;rows_patch;These functions provide a framework for modifying rows in a table using a second table of data. The two tables are matched by a set of key variables whose values typically uniquely identify each row. The functions are inspired by SQL's INSERT, UPDATE, and DELETE, and can optionally modify in_place for selected backends.rows_insert() adds new rows (like INSERT). By default, key values in y must not exist in x. rows_append() works like rows_insert() but ignores keys. rows_update() modifies existing rows (like UPDATE). Key values in y must be unique, and, by default, key values in y must exist in x. rows_patch() works like rows_update() but only overwrites NA values. rows_upsert() inserts or updates depending on whether or not the key value in y already exists in x. Key values in y must be unique. rows_delete() deletes rows (like DELETE). By default, key values in y must exist in x.
129;rows_upsert;These functions provide a framework for modifying rows in a table using a second table of data. The two tables are matched by a set of key variables whose values typically uniquely identify each row. The functions are inspired by SQL's INSERT, UPDATE, and DELETE, and can optionally modify in_place for selected backends.rows_insert() adds new rows (like INSERT). By default, key values in y must not exist in x. rows_append() works like rows_insert() but ignores keys. rows_update() modifies existing rows (like UPDATE). Key values in y must be unique, and, by default, key values in y must exist in x. rows_patch() works like rows_update() but only overwrites NA values. rows_upsert() inserts or updates depending on whether or not the key value in y already exists in x. Key values in y must be unique. rows_delete() deletes rows (like DELETE). By default, key values in y must exist in x.
130;rows_delete;These functions provide a framework for modifying rows in a table using a second table of data. The two tables are matched by a set of key variables whose values typically uniquely identify each row. The functions are inspired by SQL's INSERT, UPDATE, and DELETE, and can optionally modify in_place for selected backends.rows_insert() adds new rows (like INSERT). By default, key values in y must not exist in x. rows_append() works like rows_insert() but ignores keys. rows_update() modifies existing rows (like UPDATE). Key values in y must be unique, and, by default, key values in y must exist in x. rows_patch() works like rows_update() but only overwrites NA values. rows_upsert() inserts or updates depending on whether or not the key value in y already exists in x. Key values in y must be unique. rows_delete() deletes rows (like DELETE). By default, key values in y must exist in x.
131;all_equal;all_equal() allows you to compare data frames, optionally ignoring row and column names. It is questioning as of dplyr 1.0.0, because it seems to solve a problem that no longer seems that important.
132;sample_n;sample_n() and sample_frac() have been superseded in favour of slice_sample(). While they will not be deprecated in the near future, retirement means that we will only perform critical bug fixes, so we recommend moving to the newer alternative. These functions were superseded because we realised it was more convenient to have two mutually exclusive arguments to one function, rather than two separate functions. This also made it to clean up a few other smaller design issues with sample_n()/sample_frac:The connection to slice() was not obvious. The name of the first argument, tbl, is inconsistent with other single table verbs which use .data. The size argument uses tidy evaluation, which is surprising and undocumented. It was easier to remove the deprecated .env argument. ... was in a suboptimal position.
133;sample_frac;sample_n() and sample_frac() have been superseded in favour of slice_sample(). While they will not be deprecated in the near future, retirement means that we will only perform critical bug fixes, so we recommend moving to the newer alternative. These functions were superseded because we realised it was more convenient to have two mutually exclusive arguments to one function, rather than two separate functions. This also made it to clean up a few other smaller design issues with sample_n()/sample_frac:The connection to slice() was not obvious. The name of the first argument, tbl, is inconsistent with other single table verbs which use .data. The size argument uses tidy evaluation, which is surprising and undocumented. It was easier to remove the deprecated .env argument. ... was in a suboptimal position.
134;top_n;top_n() has been superseded in favour of slice_min()/slice_max(). While it will not be deprecated in the near future, retirement means that we will only perform critical bug fixes, so we recommend moving to the newer alternatives. top_n() was superseded because the name was fundamentally confusing as it returned what you might reasonably consider to be the bottom rows. Additionally, the wt variable had a confusing name, and strange default (the last column in the data frame). Unfortunately we could not see an easy way to fix the existing top_n() function without breaking existing code, so we created a new alternative.
135;top_frac;top_n() has been superseded in favour of slice_min()/slice_max(). While it will not be deprecated in the near future, retirement means that we will only perform critical bug fixes, so we recommend moving to the newer alternatives. top_n() was superseded because the name was fundamentally confusing as it returned what you might reasonably consider to be the bottom rows. Additionally, the wt variable had a confusing name, and strange default (the last column in the data frame). Unfortunately we could not see an easy way to fix the existing top_n() function without breaking existing code, so we created a new alternative.
136;scop;"Scoped verbs (_if, _at, _all) have been superseded by the use of across() in an existing verb. See vignette(""colwise"") for details. The variants suffixed with _if, _at or _all apply an expression (sometimes several) to all variables within a specified subset. This subset can contain all variables (_all variants), a vars() selection (_at variants), or variables selected with a predicate (_if variants). The verbs with scoped variants are:mutate(), transmute() and summarise(). See summarise_all(). filter(). See filter_all(). group_by(). See group_by_all(). rename() and select(). See select_all(). arrange(). See arrange_all() There are three kinds of scoped variants. They differ in the scope of the variable selection on which operations are applied:Verbs suffixed with _all() apply an operation on all variables. Verbs suffixed with _at() apply an operation on a subset of variables specified with the quoting function vars(). This quoting function accepts tidyselect::vars_select() helpers like starts_with(). Instead of a vars() selection, you can also supply an integerish vector of column positions or a character vector of column names. Verbs suffixed with _if() apply an operation on the subset of variables for which a predicate function returns TRUE. Instead of a predicate function, you can also supply a logical vector."
137;all_vars;"all_vars() and any_vars() were only needed for the scoped verbs, which have been superseded by the use of across() in an existing verb. See vignette(""colwise"") for details. These quoting functions signal to scoped filtering verbs (e.g. filter_if() or filter_all()) that a predicate expression should be applied to all relevant variables. The all_vars() variant takes the intersection of the predicate expressions with & while the any_vars() variant takes the union with |."
138;any_vars;"all_vars() and any_vars() were only needed for the scoped verbs, which have been superseded by the use of across() in an existing verb. See vignette(""colwise"") for details. These quoting functions signal to scoped filtering verbs (e.g. filter_if() or filter_all()) that a predicate expression should be applied to all relevant variables. The all_vars() variant takes the intersection of the predicate expressions with & while the any_vars() variant takes the union with |."
139;vars;"vars() was only needed for the scoped verbs, which have been superseded by the use of across() in an existing verb. See vignette(""colwise"") for details. This helper is intended to provide equivalent semantics to select(). It is used for instance in scoped summarising and mutating verbs (mutate_at() and summarise_at()). Note that verbs accepting a vars() specification also accept a numeric vector of positions or a character vector of column names."
